
function [responses,config] = compose_waves(varargin)
% models.compose_waves( ... )
%   Generates a PDF of a set of simulated recordings as generated by 
% models.ongoing_activity. There are three ways to select the body of
% simulations to plot: 
%  plots.response_waves('sub~/waves/wave-type') : with a path or bids-path
%  plots.response_waves(..., '-dir','sub~/waves/wave-type') : as option 1
%  plots.response_waves('-wave-type') : attempt to use default path for
%                                       specified type. One of: 
%                                     { flat, base, drift, burst, ecap }
% 
% Command-line arguments may be supplied as the follows: 
% -pdf         : enable PDF generation
% -gather-data : suppress figure generation and inject gathered responses
%                 and response metadata into the calling workspace as 
%                `pop_response` and `pop_info`
% -wave        : instead of generating a summary analysis PDF, 
% -spectra     : show results of spectral analysis (mtspectrumc)
%                (if Chronux not configured, uses pwelch)
% -raster      : show spike raster where relevent
% 
% Data import options:
% -dir `path`  : use specified directory for recordings  
% -base `path` : use specified directory for baseline firing rate for
%                inactive axon types 
% -quick       : skip pairwise groups during import
% 
% Data processing options:
% -noise 0.1 (µV) : define Gaussian noise amplitude
% -roi 25 (ms)   : define time window to exclude edge effects 
%                   (symmetric around 0 or 2-elementvector)
% -elec [...]    : define recording electrode pairs 
%                   (synonymous with -chan, -pair)
% -fasc [1:nF]   : reduce recording to the specified fascicle IDs
% 
% v0.4 CDE 07-Sep-2020
varargin = tools.opts_to_args(varargin,'compose');
named = @(v) strncmpi(v,varargin,length(v)); 
get_ = @(v) varargin{find(named(v))+1};

do.plot_waves = any(named('-plot')) || any(named('-pdf')); 
do.plot_raster = any(named('-plot-r'));
do.get_spectra = ~any(named('-no-sp'));
do.pdf = any(named('-pdf')); 

make_wave_figure; % reset plot function

%% Get source files 

if any(named('--c')), config = get_('--c');   
else                  config = set_configuration(varargin{:}); 
end

if ~isfield(config,'path'), return, end % Escaped

data_ = @(x) [config.path x]; 
list = dir(data_('*.mat'));

% [pop_code,~,pop_index] = unique(config.metadata(:,config.idx_ok),'rows');

load(data_(list(1).name),'options')

axon_type = options.class;
aff = [options.afferent]; 
axon_type(aff)  = cellfun(@(s) sprintf('%s (A)',s), axon_type(aff),'unif',0);
axon_type(~aff) = cellfun(@(s) sprintf('%s (E)',s), axon_type(~aff),'unif',0);

% do.sim_name = config.s(config.id).wave_path;

%% Load baseline files 

if any(named('--b')), base = get_('--b');   
else                  base = get_baseline(data_, config, varargin{:}); 
end

if any(named('-get-base')), responses = base; return, end

%% Set up wave composition options 

if any(named('--t')),     wave_opts = get_('--t'); 
elseif any(named('--w')), wave_opts = get_('--w'); 
else                      wave_opts = set_wave_options(varargin{:}); 
end

if any(named('-get-co')), responses = wave_opts; return, end

if do.get_spectra
  chronux_opts = tools.setupChronux; 
  chronux_opts.Fs = []; 
  chronux_opts.fpass = [0.2 4e3]; 
end

%%

responses = {}; 
fprintf('from %s:\n', regexp(list(1).folder,'[\\/][^\\/]+$','match','once'))

for aa = 1 : numel(wave_opts)
    
  W = wave_opts(aa);

  if isnumeric(W.file_id), 
    file_list = W.file_id; 
  elseif strncmpi(W.file_id,'first',2), 
    file_list = ones(size(W.active_types)); 
  elseif strncmpi(W.file_id,'all',2), 
    file_list = (1:numel(list))' * ones(size(W.active_types)); 
  end
  
%   if isnumeric(W.bipolar_pair), bipolar = W.bipolar_pair;
%   else bipolar = [1 2; 3 4]; 
%   end
    
  txt = sprintf(', %s', axon_type{W.active_types(1,:)});
  fprintf('Loading active axons = [%s ] ... ', txt(2:end))

% get_roi_ = @(t)  (t >= min(time_range) & t <= max(time_range));  
% nB = size(bipolar,1); 
% C = lines(max(7,nB)); G = @(v) [v v v]/10; 

  nB = []; % to be determined below
  nA = numel(axon_type);


  %% Load population-modulated spiking files

  tools.printInfo(); 
  model = [];
  in = []; 

  for f_row = 1:size(file_list,1), 
    
    waves = [];
    spike = cell(1,nA); 
    
    %% Load "active types" 
    active_types = get_prop_(W,'active_types',f_row);
    fascicle_ids = get_prop_(W,'fascicle_ids',f_row);    
    
    f_these = file_list(f_row,:);     
    f_order = order_intelligently(in,f_these); % reduce redundant data loading
    
    for f_col = f_order % Advanced composition 
      ff = f_these(f_col);
      ty = active_types(f_col); 
      
      if isempty(in) || in.id ~= ff
        tools.printInfo('%s ',list(ff).name)
        in = load(data_(list(ff).name),'waves','time','raster');
        in.id = ff; 
        
        if numel(W.input_roi) > 1 % Parse TIME region-of-interest
          roi = (in.time >= min(W.input_roi) & ...
                 in.time <= max(W.input_roi));  
        elseif W.input_roi < 0          
          roi = abs(in.time) < (max(abs(in.time)) + W.input_roi);
        else roi = abs(in.time) < W.input_roi;
        end
        
        % Still not happy with the behaviour of the current-sensitivity
        % product at the boundary, use this to detrend: 
        in.waves = tools.detrend_wave(in.waves,in.time,roi);
        
        if ischar(W.bipolar_pair)
          W.bipolar_pair = reshape(1:size(in.waves,2),2,[])';
        end
        
      end % load waves 
      
      if isempty(nB), nB = size(W.bipolar_pair,1); end
      
      if ndims(in.waves) == 4, % waves ~ time, channel, fascicle, cell_type
        if isnumeric(fascicle_ids)
          ok = (fascicle_ids <= size(in.waves,3));
          if f_row == 1 && f_col == 1, 
            tools.printInfo('%s; F={%s%s} ] ',ones(7,1)*8,sprintf('%d,',fascicle_ids(ok)),8)
            tools.printInfo();
          end
             wraw = squeeze(sum(in.waves(:,:,fascicle_ids(ok),ty),3));
        else wraw = squeeze(sum(in.waves(:,:,:,ty),3));
        end
      else
        wraw = in.waves(:,:,ty); 
        if isnumeric(fascicle_ids) && ff == 1 && aa == 1
          warning('ViNERS:noFascicleInfo','-fasc was passed as %s %s.', ...
                        'an option but these simulations don''t', ... 
                        'contain any fascicle-level data, ignoring')
        end
      end

      if isempty(waves)
        waves = zeros([size(wraw) nA]);
      end
            
      waves(:,:, ty ) = wraw ; 
      
      if iscell(in.raster), spike{ty} = in.raster{ty}; % from models.random_raster
      else spike{ty} = in.raster(ty); % from models.nerve_stimulation
      end
    end
      
    %% Then load baseline contributions 
    f_col = setdiff(1:nA,active_types);
    b_idx = ceil(rand(size(f_col)) * numel(base));
    for ty = f_col,      
      if isempty(base)        
        B.wave = zeros(size(waves)); 
        B.spike{ty}.axon_index = ones(0,1);
        B.spike{ty}.spike_fraction = ones(4,1);
        B.spike{ty}.filename = 'empty';                
        B.spike{ty}.dt_dx = ones(0,1);
        B.spike{ty}.spike = [];
        B.spike{ty}.axon_group = ones(1,0);        
      else B = base(b_idx(f_col == ty));       
      end
      waves(:,:,ty) = B.wave(:,:,ty); %#ok<AGROW>
      spike{ty} = B.spike{ty};
    end    
    
    %% Merge waves based on bipolar config
    
    if 0, plot(in.time(roi),waves(roi,:) + (1:(4*4))), end %#ok<UNRCH>
    waves = sum(waves(roi,:,:),3); % remove type channel after baseline substitution
    
    for ty = 1:numel(spike), 
      if isfield(spike{ty},'bin_time'), continue, end
      spike{ty} = convert_spike_struct(spike{ty},spike,in);
    end
    try spike = [spike{:}];
    catch C, warning(C.message)
    end
    
    clear ty f_col b_idx B wraw ff ok
        
    waves = waves(:,W.bipolar_pair(:,1)) - waves(:,W.bipolar_pair(:,2));
    waves = waves + randn(size(waves)) * W.input_noise; % Add gaussian noise

    this = struct;
    this.file = f_these;
    
    if any(named('-raster')) this.raster = spike; end
    
    
    if any(named('-nominal'))
          this.spk_rate = cat(1,spike.bin_rate); % nominal spike rate
    else  this.spk_rate = cat(1,spike.spk_rate); % actual spike rate
    end
    this.spk_time = spike(1).bin_time; 
    this.wave = waves; 
    
    if do.get_spectra
      chronux_opts.Fs = 1000 / mean(diff(in.time)); % units of kS/s
      
      if isempty(which('mtspectrumc'))          
           [this.spect,hz] = pwelch(waves, [],[],[],chronux_opts.Fs);
            this.spect(hz > hz(end)/2,:) = []; 
            hz(hz > hz(end)/2,:) = []; 
            this.hz = hz;          
      else [this.spect,this.hz] = mtspectrumc(waves,chronux_opts);      
      end
    end
    
    if isempty(model), model = this;
    else               model(end+1) = this; %#ok<AGROW>
    end
    
    %%    
    if do.plot_waves, make_wave_figure(do,this,W), end
      
  end % for each file in this configuration group
  
  clear f_order f_row f_these fascicle_ids
  responses{aa} = model;
  wave_opts(aa) = W; % capture changes eg 'default' --> [1 2; 3 4]
  fprintf(newline)
  
end

make_wave_figure(do,'combine') % Generate PDF pages (if needed)
    
responses = cat(1,responses{:}); 

config.axon_type = axon_type;
config.active_ty = {wave_opts.active_types}; 
config.path = data_('');

[pop_code,~,pop_index] = unique(config.metadata(:,config.idx_ok),'rows');

config.group = pop_index;
config.spikerate = pop_code; 

config.meta_col = config.idx; 
config.sim_settings = config.s(config.id); 
config.wave_settings = wave_opts; 

config.time = in.time(roi); 

config = rmfield(config,{'s','id','fmt','idx','idx_ok'});
config = orderfields(config);

% did the input files contained a variable called stimulus? if so, get it
if ~isempty(whos('-file',data_(list(1).name),'stimulus'))
  in = load(data_(list(1).name),'stimulus');   
  config.stimulus = in.stimulus;
end


return

%% if -pdf or -plot requested, use this to make panels
function make_wave_figure(do,this,W)

persistent ps_folder
if nargin == 0, ps_folder = []; return, end


if ischar(this) % 
  if do.pdf
   file = tools.file('get','Population_waves (%d).pdf','next');
   combine_PStoPDF([tempdir ps_folder], file )
   clc
  end
  return
end

axon_type = evalin('caller','axon_type');
active_type = evalin('caller','active_types');
ff = this.file(1); 

list = evalin('caller','list');
time = evalin('caller','in.time(roi)');
bipolar = W.bipolar_pair;

nB = size(this.wave,2); 
C = lines(max(7,nB)); G = @(v) [v v v]/10;

%%
figure(1), clf
txt = sprintf(', %s', axon_type{active_type});  
txt = sprintf('\\rm%s: %s', txt(3:end), strrep(list(ff).name,'_','\_'));

if do.pdf  
 if isempty(ps_folder), ps_folder = 'make-pdf\'; 
  if exist([tempdir ps_folder],'dir'), rmdir([tempdir ps_folder],'s'); 
  end,                                 mkdir([tempdir ps_folder]);
 end
end
  
nSP = 1 + do.plot_raster + do.get_spectra;
if nSP == 4, subplot_ = @(n) subplot(2,2,n);
else         subplot_ = @(n) subplot(nSP,1,n);
end, pid = 1; 
    
get_roi_ = @(t) t > min(time) & t < max(time);

if do.plot_raster
  %%
  raster = evalin('caller','spike');  
  
  subplot_(1), cla, hold on
  dy = cumsum([0 cellfun(@numel,{raster.axon_group})+10]);
  
  roi_k = get_roi_(this.spk_time);
  px = mean(diff(this.spk_time))/2;
  px = [this.spk_time(roi_k)-px; this.spk_time(roi_k)+px];
  px = px([1 1:end end]);

  sr = [1;1]*sum(this.spk_rate(:,roi_k)); 
  sr = [0 sr(:)' 0];

  fill(px,sr,G(6),'LineWidth',1.2,'EdgeColor','none','FaceAlpha',0.4)

  py = sum(cat(1,raster.bin_rate));
  plot(this.spk_time(roi_k),py(roi_k),'--','Color',G(4),'LineWidth',1.2)

  px = cat(1,raster.spk_time); 
  
  
  
  roi_k = get_roi_(px); % units of ms
  py = arrayfun(@(r) raster(r).spk_axon + dy(r), 1:4,'unif',0);
  py = cat(1,py{:}) / dy(end)*max(sr); % + max(sr); 


  if any(named('-raster-k'))
    plot(px(roi_k),py(roi_k),'.','Color',G(4),'MarkerSize',6)
  else

    if ~exist('pop','var')
      load(tools.file('get','sub~/axons/axon*.mat','newest'),'pop');
    end

    pc = arrayfun(@(n) n*ones(size(raster(n).spk_time)), ...
                       1:numel(raster),'Unif',0);
    pc = cat(1,pc{:}); 
    scatter(px(roi_k),py(roi_k),40,pop.axon_color(pc(roi_k),:),'.')

  end

  axis tight, tools.tidyPlot

  title(txt,'Color',G(7))
  pid = pid+1; 
end
%%
if 1, subplot_(pid), cla, hold on % Recorded waves 
  dy = 1.5 * quantile(abs(this.wave(:)), 0.98);

  for cc = 1:nB    
    plot(time, this.wave(:,cc) + (cc-1)*dy,'-')    
    text(max(time) + 1, (cc-1)*dy, ['E' sprintf('%d',bipolar(cc,:))], ... 
                    'color',C(cc,:),'FontSize',14)
  end
  axis tight, tools.tidyPlot

  if pid == 1, title(txt,'Color',G(7)), end
  pid = pid + 1; 
end
%%
if do.get_spectra, subplot_(pid), cla, hold on  % Chronux spectrum      
  for cc = 1:nB
    plot(this.hz,this.spect(:,cc),'color',C(cc,:),'LineWidth',1.3)
  end
  axis tight, tools.tidyPlot

  pid = pid + 1; 
end
%%
if do.pdf
  ati = evalin('caller','aa');  
     figs_to_ps(gcf,sprintf('%sw%03d-ty%02d-wave.ps',ps_folder,ff,ati),'-move');
     pause(0.1), close(gcf),  printInfo(); 
else pause(0.1)
end


return

%% Default Input configuration 
function config = set_configuration(varargin)

named = @(v) strncmpi(v,varargin,length(v)); 
get_ = @(v) varargin{find(named(v))+1};

%%

config.s = models.nerve_recording('-list-modes'); 
config.id = arrayfun(@(c) any(named(['-' c.wave_path])), config.s); 

w_dir = ''; 

if any(config.id)
  w_dir = tools.file(['sub~\waves\' config.s(config.id).wave_path '\']);
end

if any(named('-dir')), w_dir = get_('-dir'); % user specified folder
  if any(w_dir == '~'), w_dir = tools.file(w_dir); end  
elseif nargin > 0 && varargin{1}(1) ~= '-' % leading entry
  w_dir = varargin{1}; 
  wp = tools.file('sub~\waves\');
  if any(w_dir == '~'), w_dir = tools.file(w_dir);
  elseif ~isfolder(w_dir) && isfolder([wp w_dir]), w_dir = [wp w_dir]; 
  end  
  if ~ismember(w_dir(end),filesep), w_dir = [w_dir filesep]; end
  config.id = arrayfun(@(c) contains(w_dir,[filesep c.wave_path]), config.s); 
end

if ~isfolder(w_dir) % not supplied, use file picker menu
  %%
  [w_dir] = uigetdir(tools.file('sub~\waves\'));
  if ~ischar(w_dir), return, end % Selecion cancelled, exit gracefully
  config.id = arrayfun(@(c) contains(w_dir,[filesep c.wave_path]), config.s); 
  if ~ismember(w_dir(end),filesep), w_dir = [w_dir filesep]; end
end

if contains(w_dir,[filesep 'stim']) % ECAP from simulated spiketimes

  config.s(1).name = 'stimulus';
  config.s(1).n_reps = 1;
  config.s(1).coherence = 1;
  config.s(1).spikerate = 1:numel(dir([w_dir '*.mat']));
  config.s(1).file_scheme = 'stim_n%d (%%d).mat';
  config.s(1).wave_path = 'stimulus'; 
  config.id = 1;
end

if ~any(config.id), error('%s is not on my list of folders', w_dir), end

config.id = find(config.id,1);
config.path = w_dir; 

% Remove extraneous formatting, leading text, and (etc) bits
config.fmt = strtrim(regexprep(config.s(config.id).file_scheme,'\(.*','')); 
config.fmt = regexprep(config.fmt,'^[^_]+_','_');
config.fmt = regexprep(config.fmt,'%0?\.?\d*([df])','%$1');

w_dir = @(x) [w_dir x];
list = dir(w_dir('*.mat'));

config.idx = config.fmt(2:4:end);
sel = ~ismember(config.idx,'bc'); % Don't include these in pop_code indices
if ~any(sel), sel(1) = true; end

config.metadata = regexp({list.name},[config.fmt(1:2) '[^\(]+'],'match','once'); 
config.metadata = cellfun(@(c)sscanf(c,config.fmt),config.metadata,'unif',0);
config.metadata = [config.metadata{:}]';

if size(config.metadata,2) ~= numel(config.idx) % something funny happened
  % This can be caused by out-of-order filename tokens
  
  ctext = regexp({list.name},[config.fmt(1:2) '[^\(]+'],'match','once');   
  config.metadata = zeros(numel(ctext),numel(sel)); 
  
  if all(cellfun(@isempty,ctext))
    ctext = regexp({list.name},'_[^\d]*[^\(]+','match','once'); % even wider
    val = regexp(ctext,'(?<=_[^\d]*)-?(\d+\.)?\d+','match');    
    val = str2double(cat(1,val{:}));
    config.metadata = val;
  else
   for u = find(config.fmt == '_')
    rexpr = ['(?<=' config.fmt(u+(0:1)) ')-?(\d+\.)?\d+']; 
    val = str2double(regexp(ctext,rexpr,'match','once'));    
    config.metadata(:,config.fmt(2:4:end) == config.fmt(u+1)) = val;
   end
  end
end

config.idx_ok = sel;

%% Default Output configuration
function s = set_wave_options(varargin)

named = @(v) strncmpi(v,varargin,length(v)); 
get_ = @(v) varargin{find(named(v))+1};

% Gather optional inputs to set up default values:  

d.noise = 0.01; % uV = 1 nV
d.time  = -25;
d.shift = 0;
d.gain  = 1;
d.chan = 'default'; 
d.fascicle = 'all'; 

if any(named('-noise')), d.noise = get_('-noise');  end
if any(named('-shift')), d.shift = get_('-shift');  end
if any(named('-roi')),   d.time = get_('-roi');     end
if any(named('-gain')),  d.gain = get_('-gain');    end
if any(named('-fasc')), d.fascicle = get_('-fasc'); end
if any(named('-pair')), d.chan = get_('-pair'); end % vague synonyms
if any(named('-elec')), d.chan = get_('-elec'); end
if any(named('-chan')), d.chan = get_('-chan'); end

active_type_list = {1, 2, 3, 4, [1 2], [3 4], [1 3], [2 4], [1 2 3 4]};

if any(named('-quic')) || any(named('-fast')), active_type_list(5:8) = []; end
if any(named('-type')), active_type_list = get_('-type'); end


% size_check_ = @(u) all(size(u) == 1) || ...
%                    all(size(u) == size(d.axonClass)); 
% for prop = {'noise','time','gain','shift'}
%   if size_check_(d.(prop{1})), continue, end
%   error('%s was an invalid size (must be 1x1 or %dx%d, was %dx%d)', ... 
%             prop{1},size(d.axonClass), size(d.(prop{1})))
% end

s = []; 

for ff = 1:numel(active_type_list)

  this = struct; 
  this.file_id = 'all';
  this.active_types = active_type_list{ff};
  this.fascicle_ids = d.fascicle;
  this.bipolar_pair = d.chan;  
  this.input_shift = d.shift; 
  this.input_gain  = d.gain;
  this.input_noise = d.noise;
  this.input_roi   = d.time; 
  
  if isempty(s), s = this;
  else s(end+1) = this; %#ok<AGROW>
  end  
end

return

%% Collection of data for baseline responses
function base = get_baseline(data_, config, varargin)

named = @(v) strncmpi(v,varargin,length(v)); 
get_ = @(v) varargin{find(named(v))+1};

%%
sel = []; 

if contains(config.path,'(')
  base = dir(regexprep(config.path,'(?<=waves[\\/])[^(]*\(([^\)]*).*','base*($1)*'));  
  if numel(base) == 1, base = [base.folder filesep base.name];
  else base = ''; 
  end
else base = ''; 
end

if ~isfolder(base), base = tools.file('sub~\waves\base\'); end
if ~isfolder(base), base = tools.file('sub~\waves\flat\'); end
if any(named('-base')), base = get_('-base'); 
   if any(base == '~'), base = tools.file(base); end   
   if ~exist(base,'dir') && ~strcmpi(base,'self'), 
     base = [tools.file('waves~\') base]; 
   end
end
if strcmpi(base,'self'), base = data_('');
  if any(config.idx == 'b'), sr = config.metadata(:,config.idx == 'b');
  else                       sr = config.metadata(:,config.idx == 'k');
  end  
  sel = (sr == min(sr));
end
  
if ~isfolder(base), % Not found or incorrectly specified
  
  if any(config.idx == 'b'), sr = config.metadata(:,config.idx == 'b');
  else                       sr = config.metadata(:,config.idx == 'k');
  end  
  
  warning('ViNERS:missingBaseline',...
          'Could not find %s, using min spikerate (_k%0.1f) files in %s (%d files)\n%s', ... 
          strrep(tools.file('sub~\waves\base\'),tools.file,'~'), ...
          min(sr), strrep(data_(''),tools.file,'~'), sum(sr == min(sr)), ...
          'you can also use -base ''~/path/to/base''')
  base = data_('');
  
  sel = (sr == min(sr));
  
end
if ~ismember(base(end),'/\'), base = [base '/']; end

%% Build list, select relevent files if not already done so

base_ = @(x) [base x];
blist = dir(base_('*.mat'));
if isempty(sel)
  sel = contains({blist.name},'_b0.1_c'); 
  if ~any(sel), sel = contains({blist.name},'_k0.1_c'); end
  if ~any(sel), sel = contains({blist.name},'0.1kps_vzt[1.0,1.0,1.0]'); end
end

blist = blist(sel);

base = []; 
 
for ff = 1:length(blist) % Load baseline files from E(2020-02-20)

    load(base_(blist(ff).name),'time','waves','raster')
    roi = (time >= -25 & time <= 25); % units of ms    
    if ndims(waves) == 4, waves = squeeze(sum(waves,3)); end
    waves = tools.detrend_wave(waves,time,roi);

    this = struct; 
    this.file = blist(ff).name;
    this.wave = waves;
    this.spike = raster;

    if isempty(base), base = this;
    else base(end+1) = this; %#ok<AGROW>
    end
end

if numel(blist) > 1
  fprintf('Baseline loaded from %s\n', regexp(blist(1).folder,'[\\/][^\\/]+$','match','once'))
end

return

%% Helper functions 
function order = order_intelligently(loaded,fids) % IN-CONTEXT FUNCTION

if numel(unique(fids)) == 1, order = 1:numel(fids); return, end

rr   = evalin('caller','f_row');
all_fids = evalin('caller','file_list'); 

if ~isempty(loaded) && any(fids == loaded.id)
     order = find(loaded.id == fids); 
else order = []; 
end

todo = ~ismember(fids,fids(order));

if rr < size(all_fids,1)
  
  post = ismember(all_fids(rr+1,:),fids(todo)); 
  
  if any(post), cc = find(post,1); 
    todo(fids == all_fids(rr+1,cc)) = 0; 
    post = find(fids == all_fids(rr+1,cc)); 
  else post = []; 
  end
else post = [];
end
  
idx = find(todo);
[~,seq] = sort(fids(todo)); 
order = [order idx(seq) post];

return

function p = get_prop_(W,propName,ff)
p = W.(propName);
if ischar(W.file_id), return, end
if ischar(W.(propName)), return, end
if size(W.(propName),1) ~= size(W.file_id,1), return, end
p = p(ff,:);




function this = convert_spike_struct(spk, ref, dat)

sel = cellfun(@(r) isfield(r,'bin_time'),ref);

if any(sel), 
  sel = find(sel,1);   
  this = ref{sel}; 
else 
  this = struct;
  this.spk_time = [];  
  this.spk_axon = []; 
  this.bin_time = unique([ (0:max(dat.time)) -(0:max(dat.time)) ]);   
end

this.spk_time = [];
this.spk_axon = []; 

if isempty(spk.spike)
  
  this.spk_rate = 0 * this.bin_time;
  this.bin_rate = 0 * this.bin_time;
  this.pop_rate(:) = 0; 
  this.axon_group = []; 
  return
end

index = find(~cellfun(@isempty,{spk.spike.time})); 

for ii = index

  n_init = [1; spk.spike(ii).init(:,2); max(spk.spike(ii).node)];  
  n_meas = unique(spk.spike(ii).node);
  n_dist = mean(abs(n_meas - n_init').^0.5,2);
  [~,sel] = max(n_dist);   
  sel = (spk.spike(ii).node == n_meas(sel));
  
  this.spk_time = [this.spk_time; spk.spike(ii).time(sel)];
  this.spk_axon = [this.spk_axon; ii*sel(sel)];
end

this.spk_rate = []; 

if ~isfield(this, 'bin_time')
  this.bin_time = unique([ (0:max(dat.time)) -(0:max(dat.time)) ]);
end

dt = mean(diff(this.bin_time));
this.spk_rate = hist(this.spk_time,this.bin_time); %#ok<HIST>
this.spk_rate = this.spk_rate/dt * 1000 / numel(spk.axon_group);

k = gausswin(9); k = k/sum(k);
this.bin_rate = conv(this.spk_rate,k,'same');

dt = mean(diff(dat.time));
this.pop_rate = hist(this.spk_time,dat.time); %#ok<HIST>
this.pop_rate = this.pop_rate/dt * 1000 / numel(spk.axon_group);

this.axon_group = spk.axon_group;

return
