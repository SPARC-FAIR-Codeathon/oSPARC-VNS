
function d = read_NRN_datfile(filename,varargin)
% returns or plots NRN dat_file generated by models.axon_model
% 
% This function is part of the standard suite of local result caching tools
%   implemented by Calvin Eiber for the MATLAB + NEURON simulation.
% 
% version 0.4  03-Jun-2020  Calvin Eiber (refactor to use tools.cache)
% version 0.3  21-May-2020  Calvin Eiber (added .info)

if nargin == 0, 
    [filename,fpath] = uigetfile('NEURON*.dat', ... 
                                 'Select NEURON data file', ... 
                                 tools.cache('path')); 
     filename = [fpath filename];
elseif isnumeric(filename)   
    filename = sprintf('%sNEURON_vm%d.dat',tools.cache('path'), filename);
end


named = @(v) strncmpi(v,varargin,length(v));
get_ = @(v) varargin{find(named(v))+1}; 

do_progressBar = any(named('-b')) || any(named('-p'));
do_info_only = any(named('-i')); 

t_max = [];
if any(named('-t')), t_max = get_('-t'); end



f = fopen(filename,'rt');

if f < 0 % Be patient 
 for n_try = 1:20
   if isempty(getCurrentTask), break, end
   pause(rand/20)
   f = fopen(filename,'rt');
   if f > 0, break, end
 end
 assert(f > 0, 'failed to open Vm data file "%s"', filename);
end

on_done = onCleanup(@() fclose(f) );
if do_progressBar
  fseek(f,0,'eof'); 
  p_len = ftell(f);
  frewind(f); 
  [~,p_nom] = fileparts(filename);
  
  pb = waitbar(0/p_len,'...');
  pb_update = @(m) waitbar(ftell(f)/p_len, pb, strrep(sprintf( ... 
                           'Reading %s [%s]',p_nom,m),'_','\_'));
  
end
  


d_mode = ''; 

d = struct; 
d.secname = {}; % in order of appearance
d.t  = []; % ms
d.vm = []; % mV
d.info = ''; 

newline = char(10); %#ok<CHARTEN>
warn_once = true; 

%%
while ~feof(f)
       
    in = fgetl(f); 
    if ~ischar(in), continue, end
    if do_progressBar, pb_update(d_mode); end
    
    in = strtrim(in);     
    if isempty(in), continue, end
    if strncmp(in,'BEGIN',5), 
        d_mode = lower(strtrim(regexp(in,'(?<=BEGIN)[^\{]+', ...
                                         'match','once')));
        warn_once = true;
        continue 
    end
    if strncmp(in,'} END',5), d_mode = ''; continue, end
    if strncmp(in,'FORMAT',6), d_mode = 'data'; continue, end
    
    if strcmp(d_mode,''), d.info = [d.info in newline]; continue
    end
    
    if strncmp(d_mode,'sec',3) % mode = 'name'
        d.secname = [d.secname; {in}];
    elseif strncmp(d_mode,'wave_i',5)
        
        if do_info_only, break, end
        if ~isempty(t_max) && ~isempty(d.t) && d.t(end) >=  t_max
          continue
        end
      
        % regexprep is a massive performance hit at this scale
        % val = sscanf(regexprep(in,'[:,]',' '),'%f')';
        val = sscanf(in,'%f')';
        if numel(val) ~= 2*size(d.vm,2)+1 && ~isempty(d.vm)
          if ~isfield(d,'failure'), d.failure = {}; end
          d.failure(end+1) = {val}; 
          continue
        end
        if ~isfield(d,'im'), d.im = []; end
        
        d.t = [d.t; val(1)];
        d.vm = [d.vm; val(2:2:end)];
        d.im = [d.im; val(3:2:end)];
        
        
    elseif strncmp(d_mode,'wav',3)
      
        if do_info_only, break, end
        if ~isempty(t_max) && ~isempty(d.t) && d.t(end) >=  t_max
          continue
        end

        val = sscanf(in,'%f')';
        if numel(val) ~= size(d.vm,2)+1 && ~isempty(d.vm)
          if ~isfield(d,'failure'), d.failure = {}; end
          d.failure(end+1) = {val}; 
          continue
        end
        d.t = [d.t; val(1)]; 
        d.vm = [d.vm; val(2:end)]; 
    elseif strncmp(d_mode,'spikes',6)
     
        if ~isfield(d,'spk'), d.spk = {}; end
        if warn_once, d.spk{end+1} = []; warn_once = false; end
        if strncmp(in,'//',2), continue, end % ignore embedded comments
        val = [sscanf(in,'%f') ...
               sscanf(regexp(in,'\[\d+\]','match','once'),'[%d]')];
             
        d.spk{end} = [d.spk{end}; val]; 
        
        
    elseif strncmp(d_mode,'vclamp_c',8)
      
        if strncmp(in,'//',2), continue, end % ignore embedded comments
        if ~isfield(d,'im'), d.im = []; end

        if do_info_only, break, end
        if ~isempty(t_max) && ~isempty(d.t) && d.t(end) >=  t_max
          continue
        end

        val = sscanf(in,'%f')';
        d.t = [d.t; val(1)]; 
        d.vm = [d.vm; val(2)]; 
        d.im = [d.im; val(3)];

    elseif strncmp(d_mode,'vclamp_e',8) % extrema
      
        if strncmp(in,'//',2), continue, end % ignore embedded comments
        if ~isfield(d,'im'), d.im = []; end

        if do_info_only, break, end
        if ~isempty(t_max) && ~isempty(d.t) && d.t(end) >=  t_max
          continue
        end

        val = sscanf(in,'%f')'; 
        d.t = [d.t; val([2 4])]; 
        d.im = [d.im; val([1 3])];

    else
      
      if warn_once, warning('read_dat_file:unknown_datablock', ...
                               'Unrecognised block "%s"', d_mode)
        warn_once = false;
      end
      % error('Unrecognised mode %s')
        % if strncmp(d_mode,'wav',3)
    end
    
end


if do_progressBar, delete(pb), end

%% Determine if multiple t=sweeps present 

if ~isempty(d.t) && size(d.t,2) == 1 && any(diff(d.t) < 0) % multiple time sweeps 
  
  chunk_idx = find(diff([inf;d.t]) < 0);
  chunk_idx(end+1) = numel(d.t) + 1;
  
  if numel(unique(diff(chunk_idx))) == 1
    
    d.t = d.t(1:chunk_idx(2)-1);     
    if ~isempty(d.vm),  d.vm = reshape(d.vm,numel(d.t),[]); end
    if isfield(d,'im'), d.im = reshape(d.im,numel(d.t),[]); end
  else
    chunk_idx = diff(chunk_idx);
    d.t = mat2cell(d.t, chunk_idx);
    if ~isempty(d.vm),  d.vm = mat2cell(d.vm, chunk_idx); end
    if isfield(d,'im'), d.im = mat2cell(d.im, chunk_idx); end
  end
end




if nargout > 0, return, end

%%

clf
if isfield(d,'spk')
  set(gca,'ColorOrder',jet(numel(d.spk)) .* [1 .7 1]), hold on
  for ii = 1:numel(d.spk)
    plot(d.spk{ii}(:,1),d.spk{ii}(:,2),'.')
  end
else
  set(gca,'ColorOrder',jet(numel(d.secname)) .* [1 .7 1]), hold on
  plot(d.t,d.vm)
end
axis tight, tools.tidyPlot

%%
clear
return

%%
